'''
Created on Nov 20, 2015

@author: prag717
'''

import simplicialHomology as sh

def closure(complx):
    ## returns the closure of the given complex - adds all of the sublists
    n = max([len(lst) for lst in complx])
    k = n-1
    A1 = []
    while k >= 0:
        A1 += sh.ksimplices(complx,k)
        k += -1
    return A1

def sstar(toplexes, complx):
    ## computes the star of the complex in the ASC generated by the toplexes
    i = 0
    asc = closure(toplexes)

    A = list(complx)
    i += 1
    for simplex in complx:
        B = sh.star(asc,simplex)
        i+= 1
        for b in B:
            if not sh.simpcluded(b,A):
                A.append(b)
    return A

###### ToDo: make a neighborhood function which computes does the recursion to construct
######       the correct complx for locHomTable

def locHomTable(toplexes, ascdict={}, neighborhood = 1, ofile = None):
#  Computes the local homology for all faces in the ASC generated by the toplexes
#  and returns a table of the dimensions of H1, H2, and H3
#  Takes a neighborhood size 0,1,2, and an output file name
#  if nodes are named, this can go in ascdict={nodeNumber:"name"} for the table
#  otherwise names will be given by the concatenation of the index numbers

    k = 1
    ASC = closure(toplexes)
    if ofile == None:
        print " ", "\t\t", "H1" , "\t" , "H2", "\t", "H3", "\t\t", "FACE"
        print "-"*50
    else:
        ofile.write(" \t\t" + "H1" + "\t" + "H2" + "\t" + "H3" + "\t\t" + "name" + "\n")

    for cnt,splx in enumerate(ASC):
#         print cnt+1, len(ASC), splx
        
        if neighborhood == 0:
            complx = [splx]
        elif neighborhood == 1:
            complx = closure([splx])
        else:
            complx = closure(sstar(toplexes, closure([splx])))
        A = sstar(toplexes, complx)

        Hks,_=sh.localHomologyMultiproc(3,toplexes,2,A,False,True)
        H1 = Hks[0]
        H2 = Hks[1]
        H3 = Hks[2]

        name = ""
        if ascdict != {}:
            for idx in range(len(A[0])):
                name += ascdict[A[0][idx]]

        if name == "":
            name = ','.join(map(str,splx))

        if ofile == None:
            print  k, "\t\t", H1 , "\t" , H2, "\t", H3, "\t\t", name
            k += 1
        else:
            ofile.write(str(k) + "\t\t" + str(H1) + "\t" + str(H2) + "\t" + str(H3) + "\t\t" + str(name) + "\n")
            k += 1

import networkx as nx
from datetime import datetime
import time as tm

def run_graph(graph_file, output_file, neighborhood, flag = None):
    print "==== New graph ===="
    print "Input:", graph_file
    print "Output:", output_file
    print "Neighborhood:", neighborhood
    print ""

    print "Loading graph"
    print "Start time: %s" % (datetime.now())
    g=nx.read_gml(graph_file)
    print "End time: %s" % (datetime.now())

    gflag = None
    if flag == None:
        print "Creating flag complex"
        print "Start time: %s" % (datetime.now())
        gedgelist = map(list,g.edges(data=False))
        gflag = sh.flag(gedgelist,4)
        print "End time: %s" % (datetime.now())
    else:
        print "Using passed in flag complex"
        gflag = flag

    for n in range(neighborhood+1):
        print "Finding the local homology (n = %d)" % (n)
        print "Start time: %s" % (datetime.now())
        graph = graph_file.split("/")[-1]
        print output_file
        ofile = open(output_file, 'w')
        ofile.write("Local Homology (neighborhood=%d) of flag complex generated by %s\n" % (n, graph))
        locHomTable(gflag, {}, n, ofile)
        print "End time: %s" % (datetime.now())
        print "\n"

    return gflag

# Input graphs
karate  = "karate.gml"
powlaw  = "powlaw_BA100.gml"
poisson = "poisson_ER100.gml"

# Output files
karate_out = "karateOutput_%d.txt"
powlaw_out = "powerlawOutput_%d.txt"
poisson_out  = "poissonOutput_%d.txt"

if __name__ == '__main__':
    #############  Karate Graph ###############################################################
    startTime = tm.time()
    for n in range(3):
        
        flag = None
        flag = run_graph(karate, karate_out % (n), n, flag)
            
    #     #############  PowerLaw Distribution Graph ################################################
    #     flag = None
    #     flag = run_graph(powlaw, powlaw_out % (n), n, flag)
    #     
        #############  Poisson Distribution Graph ################################################
    #     flag = None
    #     flag = run_graph(poisson, poisson_out % (n), n, flag)
    
    endTime = tm.time()
    print "\n**** Total time = %f s ****\n" % (endTime-startTime)
    #############################################################################
